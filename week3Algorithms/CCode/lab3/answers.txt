sort1 uses: Bubble sort

How do you know?: From the measured execution time, sort1 would seem to be the bubble sort and sort3 would be the selection sort.
Since both algorithms still need to iterate the list, at least on bubble sort's first iteration would indicate that the list is
sorted and quits, while selection would need to iterate continuouly to `build up` the sorted segment of the list.

sort2 uses: Merge sort

How do you know?: From the measured execution time, sort2 would seem to be merge sort due to it being the fastest.

sort3 uses: Selection sort

How do you know?: From the measured execution time, sort1 would seem to be the bubble sort and sort3 would be the selection sort.
Since both algorithms still need to iterate the list, at least on bubble sort's first iteration would indicate that the list is
sorted and quits, while selection would need to iterate continuouly to `build up` the sorted segment of the list.




-- timed
time ./sort1 reversed10000.txt
real    0m0.259s

time ./sort2 reversed10000.txt
real    0m0.054s

time ./sort3 reversed10000.txt
real    0m0.137s


// From the measured execution time, sort2 would seem to be merge sort due to it being the fastest.



time ./sort1 sorted10000.txt
real    0m0.077s

time ./sort2 sorted10000.txt
real    0m0.042s

time ./sort3 sorted10000.txt
real    0m0.106s

// From the measured execution time, sort1 would seem to be the bubble sort and sort3 would be the selection sort.
Since both algorithms still need to iterate the list, at least on bubble sort's first iteration would indicate that the list is
sorted and quits, while selection would need to iterate continuouly to `build up` the sorted segment of the list.


-- check50 cs50/labs/2023/x/sort
Results for cs50/labs/2023/x/sort generated by check50 v3.3.8
:) answers.txt exists
:) answers all questions
:) correctly identifies each sort